<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><meta name="author" content="Eric Jain"><title>Fastest Java Virtual Machine? - Eric Jain's Blog</title><link rel="alternate" type="application/rss+xml" title="Eric Jain's Blog" href="/blog/atom.xml"><link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"><link rel="stylesheet" href="/blog/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"></head><body><nav class="navbar navbar-default navbar-custom"><div class="container-fluid"><div class="navbar-header"><a href="/blog/" class="navbar-brand">Eric Jain's Blog</a></div></div></nav><header class="header-section"><div class="intro-header no-img"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><h1>Fastest Java Virtual Machine?</h1><p class="post-meta">January 16, 2007</p></div></div></div></div></div></header><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role="main" class="blog-post"><p>The best choice of virtual machine is of course dependent both on the application and on the hardware the application is running on; here are the conclusions of a performance comparison with the latest batch of Java virtual machines for a web application that makes heavy use of <a href="http://www.oracle.com/database/berkeley-db.html" target="_blank" rel="external">BerkeleyDB</a> and <a href="http://lucene.apache.org/java/" target="_blank" rel="external">Lucene</a> on an off-the-shelf Intel machine with 64-bit extensions.</p>
<a id="more"></a>
<p>The test consisted of running a set of a hundred requests several times. The first few runs were ignored (though it could also have been interesting to compare how fast a virtual machine warms up). I allocated 0.5GB of heap but didn&#8217;t bother fine tuning further as <a href="http://java.sun.com/javase/6/docs/technotes/guides/management/jconsole.html" target="_blank" rel="external">jconsole</a> didn&#8217;t show any pathological garbage collector behavior in any case. JRockit was run with both <code>-Xgcprio:throughput</code> and <code>-Xgcprio:pausetime</code>. Former produces slightly better times but can have long pauses.</p>
<p>The following virtual machines were tested:</p>
<pre><a href="http://java.sun.com/javase/6/" target="_blank" rel="external">Sun Java HotSpot(TM) Server VM</a> (build 1.6.0-b105, mixed mode)
<a href="http://dev2dev.bea.com/jrockit/" target="_blank" rel="external">BEA JRockit(R)</a> (build R27.1.0-109-73164-1.5.0_08-20061129-1418-linux-ia32, compiled mode)
<a href="https://www14.software.ibm.com/iwm/web/cc/earlyprograms/ibm/java6/" target="_blank" rel="external">IBM J9 VM</a> (build 2.4, J2RE 1.6.0 IBM J9 2.4 Linux x86-32 jvmxi3260-20061218_10446 (JIT enabled)
</pre>

<p>The first observation is that all of the current virtual machines are significantly (up to 50%) faster than any of the previous generation.</p>
<p>The second observation is that I could no longer find any significant differences between the different virtual machines.</p>
<p>&#8230;except when using 64-bit versions of the virtual machines. Having to manage 64-bit pointers seems to introduce some overhead (up to 20%), so unless you need to allocate &gt;4GB of heap memory or memory-map large files (or run on a pure 64-bit machine, not tested), sticking with a 32-bit virtual machine seems like a good idea. JRockit uses <a href="http://e-docs.bea.com/jrockit/jrdocs/refman/optionXX.html#wp1021022" target="_blank" rel="external">pointer compression</a> to avoid this problem (as long as you don&#8217;t need to allocate &gt;4GB of memory).</p>
<p>All virtual machines were trivial to setup, I only had some trouble getting the web application to deploy (in Jetty) with the IBM VM (still in beta), fixed by copying Xerces to <code>lib/ext/</code>:</p>
<pre>WEB-INF/lib/standard.jar!/META-INF/fmt-1_0.tld line:1 col:5 :
  org.xml.sax.SAXParseException: White space is required between the processing instruction target and data.
</pre></article></div></div></div><footer><div class="container beautiful-jekyll-footer"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href="/atom.xml" title="RSS"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-rss"></i></span></a></li><li><a href="mailto:eric.jain@gmail.com" title="Email me"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-envelope"></i></span></a></li><li><a href="https://www.linkedin.com/in/ejain" title="LinkedIn"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-linkedin"></i></span></a></li><li><a href="https://plus.google.com/+EricJain" title="Google+"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-google-plus"></i></span></a></li><li><a href="https://github.com/ejain" title="GitHub"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-github"></i></span></a></li></ul><p class="copyright text-muted">Â© 2017 Eric Jain</p></div></div></div></footer></body></html>